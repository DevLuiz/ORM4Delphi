unit Delphi.ORM.Mapper.Test;

interface

uses System.Rtti, DUnitX.TestFramework, Delphi.ORM.Mapper, Delphi.ORM.Attributes;

type
  [TestFixture]
  TMapperTest = class
  private
    FContext: TRttiContext;

    function FindField(Table: TTable; FieldName: String): TField;
  public
    [SetupFixture]
    procedure Setup;
    [Test]
    procedure WhenCallLoadAllMustLoadAllClassesWithTheEntityAttribute;
    [Test]
    procedure WhenTryToFindATableMustReturnTheTableOfTheClass;
    [Test]
    procedure WhenLoadATableMustLoadAllFieldsToo;
    [Test]
    procedure WhenTheFieldsAreLoadedMustFillTheNameWithTheNameOfPropertyOfTheClass;
    [Test]
    procedure WhenLoadAClassMustKeepTheOrderingOfTablesToTheFindTableContinueToWorking;
    [Test]
    procedure WhenLoadAFieldMustFillThePropertyWithThePropertyInfo;
    [Test]
    procedure WhenAClassDoesNotHaveThePrimaryKeyAttributeAndHasAnIdFieldThisWillBeThePrimaryKey;
    [Test]
    procedure WhenTheClassHaveThePrimaryKeyAttributeThePrimaryKeyWillBeTheFieldFilled;
    [Test]
    procedure TheFieldInPrimaryKeyMustBeMarkedWithInPrimaryKey;
    [Test]
    procedure TheDatabaseNameOfATableMustBeTheNameOfClassRemovingTheFirstCharOfTheClassName;
    [Test]
    procedure WhenTheClassHaveTheTableNameAttributeTheDatabaseNameMustBeLikeTheNameInAttribute;
    [Test]
    procedure OnlyPublishedFieldMutsBeLoadedInTheTable;
    [Test]
    procedure WhenTheFieldHaveTheFieldNameAttributeMustLoadThisNameInTheDatabaseName;
    [Test]
    procedure EveryPropertyThatIsAnObjectMustCreateAForeignKeyInTheListOfTheTable;
    [Test]
    procedure WhenTheForeignKeyIsCreatesMustLoadTheParentTable;
    [Test]
    procedure TheParentTableMustBeTheTableLinkedToTheField;
    [Test]
    procedure WhenTheFieldIsAClassMustFillTheDatabaseNameWithIdPlusPropertyName;
    [Test]
    procedure TheFieldOfAForeignKeyMustBeFilledWithTheFieldOfTheClassThatIsAForeignKey;
    [Test]
    procedure TheLoadingOfForeingKeyMustBeAfterAllTablesAreLoadedToTheFindTableWorksPropertily;
    [Test]
    procedure WhenMapAForeignKeyIsToAClassWithoutAPrimaryKeyMustRaiseAnError;
    [Test]
    procedure WhenCallLoadAllMoreThemOneTimeCantRaiseAnError;
    [Test]
    procedure TheClassWithTheSingleTableInheritanceAttributeCantBeMappedInTheTableList;
    [Test]
    procedure WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeMustLoadAllFieldsInTheTable;
    [Test]
    procedure WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeCantGenerateAnyForeignKey;
    [Test]
    procedure WhenTheClassIsInheritedFromANormalClassCantLoadFieldsFormTheBaseClass;
    [Test]
    procedure WhenTheClassIsInheritedFromANormalClassMustCreateAForeignKeyForTheBaseClass;
    [Test]
    procedure WhenTheClassIsInheritedFromTObjectCantCreateAForeignKeyForThatClass;
    [Test]
    procedure WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeThePrimaryKeyMustBeLoadedFromTheTopClass;
    [Test]
    procedure WhenTheClassIsInheritedMustLoadThePrimaryKeyFromBaseClass;
    [Test]
    procedure WhenTheClassIsInheritedMustShareTheSamePrimaryKeyFromTheBaseClass;
    [Test]
    procedure WhenTheForeignKeyIsAClassAliasMustLoadTheForeignClassAndLinkToForeignKey;
    [Test]
    procedure WhenLoadMoreThenOneTimeTheSameClassCantRaiseAnError;
    [Test]
    procedure WhenAPropertyIsAnArrayMustLoadAManyValueLink;
    [Test]
    procedure TheTableOfManyValueAssociationMustBeTheChildTableOfThisLink;
    [Test]
    procedure TheFieldLinkingTheParentAndChildOfManyValueAssociationMustBeLoaded;
    [Test]
    procedure WhenTheChildClassIsDeclaredBeforeTheParentClassTheLinkBetweenOfTablesMustBeCreated;
    [Test]
    procedure TheManyValueAssociationMustLoadTheFieldThatGeneratedTheValue;
    [Test]
    procedure WhenAFieldIsWithTheAutoGeneratedAttributeMustLoadAsTrueThePropertyInField;
    [TestCase('AnsiChar', 'AnsiChar')]
    [TestCase('AnsiString', 'AnsiString')]
    [TestCase('Char', 'Char')]
    [TestCase('Enumerator', 'Enumerator')]
    [TestCase('Float', 'Float')]
    [TestCase('GUID', 'GUID')]
    [TestCase('Integer', 'Integer')]
    [TestCase('Int64', 'Int64')]
    [TestCase('String', 'String')]
    procedure WhenSetValueFieldMustLoadThePropertyOfTheClassAsWithTheValueExpected(FieldName: String);
    [Test]
    procedure WhenTheFieldValueIsNullMustLoadTheFieldWithTheEmptyValue;
    [Test]
    procedure WhenAFieldIsAForeignKeyThePropertyIsForeignKeyMustReturnTrue;
    [Test]
    procedure WhenAFieldIsAManyValueAssociationThePropertyIsManyValueAssociationReturnTrue;
    [Test]
    procedure WhenAFieldIsAForeignKeyThePropertyIsJoinLinkMustReturnTrue;
    [Test]
    procedure WhenAFieldIsAManyValueAssociationThePropertyIsJoinLinkReturnTrue;
    [Test]
    procedure TheFunctionGetValueFromFieldMustReturnTheValueOfThePropertyOfTheField;
    [TestCase('AnsiChar', 'AnsiChar')]
    [TestCase('AnsiString', 'AnsiString')]
    [TestCase('Char', 'Char')]
    [TestCase('Class', 'Class')]
    [TestCase('Empty Class', 'EmptyClass')]
    [TestCase('Enumerator', 'Enumerator')]
    [TestCase('Float', 'Float')]
    [TestCase('Date', 'Date')]
    [TestCase('DateTime', 'DateTime')]
    [TestCase('GUID', 'GUID')]
    [TestCase('Integer', 'Integer')]
    [TestCase('Int64', 'Int64')]
    [TestCase('String', 'String')]
    [TestCase('Time', 'Time')]
    procedure WhenGetTheValueOfTheFieldAsStringMustBuildTheStringAsExpected(FieldName: String);
    [Test]
    procedure WhenTheFieldIsMappedMustLoadTheReferenceToTheTableOfTheField;
    [Test]
    procedure WhenAClassWithManyValueAssociationHasAChildClassWithMoreThenOneForeignKeyToParentClassMustLoadTheForeignKeyWithTheSameNameOfTheParentTable;
    [Test]
    procedure WhenTheLinkBetweenTheManyValueAssociationAndTheChildTableForeignKeyDontExistsMustRaiseAnError;
    [Test]
    procedure TheNameOfManyValueAssociationLinkCanBeDefinedByTheAttributeToTheLinkHappen;
    [Test]
    procedure WhenATableIsLoadedMustFillTheMapperPropertyOfTheTable;
    [TestCase('AnsiChar', 'AnsiChar,''C''')]
    [TestCase('AnsiString', 'AnsiString,''AnsiString''')]
    [TestCase('Char', 'Char,''C''')]
    [TestCase('Class', 'Class,1234')]
    [TestCase('Enumerator', 'Enumerator,1')]
    [TestCase('Empty class', 'EmptyClass,null')]
    [TestCase('Float', 'Float,1234.456')]
    [TestCase('Date', 'Date,''2020-01-31''')]
    [TestCase('DateTime', 'DateTime,''2020-01-31T12:34:56.000''')]
    [TestCase('GUID', 'GUID,''{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}''')]
    [TestCase('Integer', 'Integer,1234')]
    [TestCase('Int64', 'Int64,1234')]
    [TestCase('String', 'String,''String''')]
    [TestCase('Time', 'Time,''12:34:56''')]
    procedure TheConversionOfTheTValueMustBeLikeExpected(TypeToConvert, ValueToCompare: String);
    [Test]
    procedure WhenThePropertyIsNullableMustMarkTheFieldAsNullable;
    [Test]
    procedure ThePrimaryKeyCantBeNullable;
    [Test]
    procedure WhenGetValueOfAndFieldNullableMustReturnEmptyIfHasNoValue;
    [Test]
    procedure WhenTheNullablePropertyIsLoadedMustReturnTheFilled;
    [Test]
    procedure WhenTheNullablePropertyIsFilledWithTheNullValueMustMarkAsNullTheValue;
    [Test]
    procedure WhenTheNullablePropertyIsFilledWithAValueMustLoadTheValue;
    [Test]
    procedure WhenThePropertyIsLazyMustFillWithTrueTheIsLazyPropertyInTheField;
    [Test]
    procedure WhenThePropertyIsLazyMustCreateTheForeignKeyToThisProperty;
    [Test]
    procedure TheFieldThatGenerateAForignKeyMustLoadThisInfoInTheField;
    [Test]
    procedure WhenTheFieldIsAForeignKeyMustAppendTheIdInTheDatabaseNameOfTheField;
    [Test]
    procedure TheFieldsMustBeOrderedByPriorityFirstPrimaryKeyThenRegularFieldsThenForeignKeysThenManyValueAssociations;
    [Test]
    procedure WhenThePropertyIsLazyLoadingAndIsntLoadedMustReturnTheKeyValueInTheGetValue;
    [Test]
    procedure WhenTheLazyPropertyIsLoadedMustReturnTheInternalValue;
    [Test]
    procedure WhenGetTheStringValueOfANullableTypeAndTheValueIsNullMustReturnTheNullStringValue;
    [Test]
    procedure WhenGetTheStringValueOfANullableTypeAndTheValueIsFilledMustReturnTheValue;
    [Test]
    procedure WhenGetTheStringValueOfLazyPropertyMustReturnTheKeyValueIfIsNotLoaded;
    [Test]
    procedure WhenGetTheStringValueOfLazyPropertyMustReturnThePrimaryKeyValueOfLoadedValue;
    [Test]
    procedure WhenSetValueToALazyPropertyCantRaiseAnyError;
    [Test]
    procedure WhenSetValueToALazyPropertyMustLoadTheValueInTheProperty;
    [Test]
    procedure WhenTheFieldHasTheDefaultAttributeMustLoadTheDefaultProperyWithTheValue;
    [Test]
    procedure WhenTheFieldHasntADefaultValueTheValueMustBeEmpty;
    [Test]
    procedure WhenTheDefaultValueIsADateMustConvertTheValueAsExpected;
    [Test]
    procedure WhenTheDefaultValueIsATimeMustConvertTheValueAsExpected;
    [Test]
    procedure WhenTheDefaultValueIsADateTimeMustConvertTheValueAsExpected;
    [Test]
    procedure WhenTheDefaultValueIsAFloatNumberMustConvertTheValueAsExpected;
    [Test]
    procedure WhenTheDefaultValueIsAnIntegerMustConvertTheValueAsExpected;
    [Test]
    procedure WhenTheDefaultValueIsAnEnumeratorMustConvertTheValueAsExpected;
    [Test]
    procedure WhenTheDefaultValueIsAnEnumeratorWithAnInvalidNameMustRaiseAnError;
    [Test]
    procedure WhenLoadTheTableMustLoadTheNameOfTheTableWithTheNameOfTheClassWithoutTheTChar;
    [Test]
    procedure WhenLoadTheFieldOfATableMustLoadTheNameOfTheFieldWithThePropertyName;
    [Test]
    procedure WhenLoadAFieldMustLoadTheFieldTypeWithTheTypeOfTheProperty;
    [Test]
    procedure WhenLoadANullableFieldMustLoadTheFieldTypeWithTheInternalNullableType;
    [Test]
    procedure WhenLoadALazyFieldMustLoadTheFieldTypeWithTheInternalLazyType;
    [Test]
    procedure IfTheFindTableNotFoundTheClassMustRaiseAnError;
    [Test]
    procedure WhenTheClassHasAForeignKeyAndTheKeyTableIsntLoadedMustLoadTheTableFirstAndNotRaiseAnError;
    [Test]
    procedure ThePrimaryKeyReferenceFieldCantBeMarkedHasAutoGenerated;
    [Test]
    procedure TheForeignKeyInTheInheritedClassMustBeAReferenceToThePrimaryKeyInfo;
    [Test]
    procedure TheFindTableWithTypeInfoMustReturnTheTableHasExpected;
    [Test]
    procedure TheFindTableWithTypeInfoMustRaiseAnErrorIfNotFindTheTable;
    [Test]
    procedure ThePrimaryKeyFieldReferenceMustHaveTheFieldTypeWithTheBaseClassType;
    [Test]
    procedure WhenTheClassHasASimpleInheritenceMustLoadTheBaseTableProperty;
    [Test]
    procedure WhenTheClassInheritsFromObjectCantRaiseAnyError;
    [Test]
    procedure IfTheBaseClassHasTheSingleTableAttributeMustLoadTheTablePropertyWithThisInfo;
    [Test]
    procedure IfTheBaseClassHasTheSingleTableAttributeCantLoadBaseTableProperty;
    [Test]
    procedure TheFindFieldFunctionMustReturnTrueIfTheFieldExistsInTheTable;
    [Test]
    procedure TheFindFieldFunctionMustReturnTheFieldDefinitionWhenFindTheField;
    [Test]
    procedure TheForeignKeyCreatedForTheInheritanceMustBeMarkedHasInheritanceLink;
    [Test]
    procedure WhenAForeignKeyFieldHasTheFieldNameAttributeThisMustBeTheDatabaseNameField;
    [Test]
    procedure WhenTheFieldHasTheUpdateCascadeAnotationMustLoadTheInfoInTheForeignKey;
    [Test]
    procedure WhenTheFieldHasTheInsertCascadeAnotationMustLoadTheInfoInTheForeignKey;
    [Test]
    procedure WhenTheFieldHasTheInsertCascadeAndUpdateCascadeAnotationMustLoadTheInfoInTheForeignKey;
    [Test]
    procedure WhenTheClassIsInheritedMustLoadTheCascadeInfoWithUpdateAndInsertCascade;
    [Test]
    procedure WhenCallGetCacheKeyMustBuildTheValueOfTheCacheKeyWithThePrimaryKeyValueFromTheClass;
    [Test]
    procedure WhenTheClassDontHaveAPrimaryKeyMustLoadTheCacheKeyWithoutThePrimaryKeyValue;
    [Test]
    procedure IfTheValueVariantIsNullValueMustReturnAEmptyTValue;
    [Test]
    procedure IfTheFieldIsAnEnumeratorMustReturnTheOrdinalValueFromVariant;
    [Test]
    procedure IfTheVariantValueIsGUIDValueMustConvertToTValueAsExpected;
    [Test]
    procedure TheAnotherVariantValuesMustJustConvertToTValue;
    [Test]
    procedure WhenCallGetCacheValueWithVariantMustBuildTheKeyAsExpected;
    [Test]
    procedure WhenCallGetCacheValueWithVariantAndTheTableDontHavePrimaryKeyMustLoadTheKeyAsExpected;
    [Test]
    procedure TheGetCacheFunctionWithAnInstanceMustBuildTheKeyWithTheClassOfTheInstanceNotFromTable;
    [Test]
    procedure WhenFillTheFieldValueOfALazyFieldAndTheValueIsNotAnInstanceOfAnObjectMustLoadTheKeyValueFromLazy;
    [Test]
    procedure WhenFillAnEmptyValueToALazyFieldTheLazyValueCantBeMarkedAsLoaded;
    [Test]
    procedure IfTheChildTableOfAManyValueAssociationHasntPrimaryKeyMustRaiseAnError;
    [Test]
    procedure ThenMakeAForeignKeyToASingleTableInheritanceMustRaiseAnError;
    [Test]
    procedure MappingAEntityWithForeignKeyToASingleInheritedClassCantRaiseError;
    [Test]
    procedure WhenLoadATableWithSingleInheritenceMustLoadTheFieldsOfAllLevels;
    [Test]
    procedure WhenTheTableIsInheritedMustLoadAllManyValueAssociationOfTheClass;
    [Test]
    procedure WhenTheFieldHasTheNoUpdateAttributeTheFieldMustBeMarkedAsReadOnly;
    [Test]
    procedure WhenSetValueToAFieldWithASharedObjectMustUpdateThePropertyHasExpected;
    [Test]
    procedure WhenSetValueToAFieldWithAStateObjectMustUpdateBothObjectsHasExpected;
    [Test]
    procedure WhenFillTheFieldValueOfALazyPropertyMustLoadPrimaryKeyFieldName;
    [Test]
    procedure WhenMappingALazyArrayClassCantRaiseAnyError;
    [Test]
    procedure WhenMappingALazyArrayClassMustLoadTheFieldWithTheExpectedPropertyValueFilled;
    [Test]
    procedure WhenGetPropertyValueMustReturnTheValueOfTheProperty;
    [Test]
    procedure WhenGetTheLazyAccessValueMustReturnTheLazyAccess;
    [Test]
    procedure TheForeignKeyDatabaseNameMustBeTheConcatenationOfTheTablesAndFieldInfo;
    [Test]
    procedure IfTheForeignKeyHasTheNameAttributeTheDatabaseNameMustBeTheAttributeValue;
    [Test]
    procedure WhenTheClassHasTheIndexAnnotationMustLoadTheIndexInfoOfTheTable;
    [Test]
    procedure WhenLoadTheIndexMustLoadTheNameOfTheIndexHasExpected;
    [Test]
    procedure WhenUseTheUniqueIndexAttributeMustMarkTheIndexAsUnique;
    [Test]
    procedure MustLoadTheFieldsInTheIndexHasExpected;
    [Test]
    procedure IfTheFieldInIndexNotExistsInTheTableMustRaiseAnError;
    [Test]
    procedure WhenTheFieldHasFieldInfoAttributeWithSpecialTypeFilledMustLoadThisInfoInTheField;
    [Test]
    procedure WhenTheFieldHasFieldInfoAttributeWithSizeFilledMustLoadThisInfoInTheField;
    [Test]
    procedure WhenTheFieldHasFieldInfoAttributeWithPrecisionAndScaleFilledMustLoadThisInfoInTheField;
    [Test]
    procedure TheFieldTablePropertyMustReturnTheFieldIfFoundIt;
    [Test]
    procedure WhenTheFieldHasDefaultValueWithAnInternalFunctionMustLoadTheInfoHasExpected;
    [Test]
    procedure WhenTheFieldIsOfDateTypeMustLoadTheSpecialTypeWithDate;
    [Test]
    procedure WhenTheFieldIsOfDateTimeTypeMustLoadTheSpecialTypeWithDateTime;
    [Test]
    procedure WhenTheFieldIsOfTimeTypeMustLoadTheSpecialTypeWithTime;
  end;

  [TestFixture]
  TFieldPrimaryKeyReferenceTest = class
  public
    [Test]
    procedure WhenGetTheValueMustReturnTheInstanceFromTheParam;
    [Test]
    procedure WhenGetTheValueMustReturnTheInstanceOfTheBaseClassOfTheInstanceParam;
    [Test]
    procedure IfTryToFillAValueMustRaiseAnError;
    [Test]
    procedure WhenTheFieldIsCreatedMustBeMarkedIsReference;
    [Test]
    procedure TheReferenceFieldMustBeMarkedHasPrimaryKey;
  end;

implementation

uses System.Variants, System.SysUtils, System.DateUtils, Delphi.ORM.Test.Entity, Delphi.ORM.Lazy, Delphi.Mock, Delphi.ORM.Shared.Obj, Delphi.ORM.Rtti.Helper;

{ TMapperTest }

procedure TMapperTest.EveryPropertyThatIsAnObjectMustCreateAForeignKeyInTheListOfTheTable;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual<Integer>(2, Length(Table.ForeignKeys));

  Mapper.Free;
end;

function TMapperTest.FindField(Table: TTable; FieldName: String): TField;
begin
  Result := nil;

  for var Field in Table.Fields do
    if Field.Name = FieldName then
      Exit(Field);
end;

procedure TMapperTest.IfTheBaseClassHasTheSingleTableAttributeCantLoadBaseTableProperty;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSingle);

  Assert.IsNull(Table.BaseTable);

  Mapper.Free;
end;

procedure TMapperTest.IfTheBaseClassHasTheSingleTableAttributeMustLoadTheTablePropertyWithThisInfo;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSingle);

  Assert.IsTrue(Table.IsSingleTableInheritance);

  Mapper.Free;
end;

procedure TMapperTest.IfTheChildTableOfAManyValueAssociationHasntPrimaryKeyMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TManyValueParentWithoutPrimaryKey);
    end, EChildTableMustHasToHaveAPrimaryKey);

  Mapper.Free;
end;

procedure TMapperTest.IfTheFieldInIndexNotExistsInTheTableMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TMyClassWithIndexWithError);
    end);

  Mapper.Free;
end;

procedure TMapperTest.IfTheFieldIsAnEnumeratorMustReturnTheOrdinalValueFromVariant;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);
  var Value: Variant := Enum3;

  Table.FindField('Enumerator', Field);

  Assert.AreEqual(Enum3, Field.ConvertVariant(Value).AsType<TMyEnumerator>);

  Mapper.Free;
end;

procedure TMapperTest.IfTheFindTableNotFoundTheClassMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.FindTable(TMyEntityWithoutEntityAttribute);
    end, ETableNotFound);

  Mapper.Free;
end;

procedure TMapperTest.IfTheForeignKeyHasTheNameAttributeTheDatabaseNameMustBeTheAttributeValue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityForeignKeyWithName);

  Assert.AreEqual('MyForeignKey', Table.ForeignKeys[0].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.IfTheValueVariantIsNullValueMustReturnAEmptyTValue;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Table.FindField('AnsiString', Field);

  Assert.IsTrue(Field.ConvertVariant(NULL).IsEmpty);

  Mapper.Free;
end;

procedure TMapperTest.IfTheVariantValueIsGUIDValueMustConvertToTValueAsExpected;
begin
  var Field: TField;
  var GUIDValue := StringToGUID('{12345678-1234-1234-1234-123456789012}');
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);
  var Value: Variant := GUIDValue.ToString;

  Table.FindField('GUID', Field);

  Assert.AreEqual(GUIDValue, Field.ConvertVariant(Value).AsType<TGUID>);

  Mapper.Free;
end;

procedure TMapperTest.MappingAEntityWithForeignKeyToASingleInheritedClassCantRaiseError;
begin
  var Mapper := TMapper.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Mapper.LoadClass(TMyEntityForeignKeyToConcrete);
    end);

  Mapper.Free;
end;

procedure TMapperTest.MustLoadTheFieldsInTheIndexHasExpected;
begin
  var Mapper := TMapper.Create;
  var MyField, MyField2: TField;
  var Table := Mapper.LoadClass(TMyClassWithIndex);

  Table.FindField('MyField', MyField);
  Table.FindField('MyField2', MyField2);

  Assert.AreEqual<NativeInt>(2, Length(Table.Indexes[2].Fields));
  Assert.AreEqual(MyField, Table.Indexes[2].Fields[0]);
  Assert.AreEqual(MyField2, Table.Indexes[2].Fields[1]);
end;

procedure TMapperTest.OnlyPublishedFieldMutsBeLoadedInTheTable;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntity);

  Assert.AreEqual<Integer>(3, Length(Table.Fields));

  Mapper.Free;
end;

procedure TMapperTest.Setup;
begin
  FContext.GetType(TClassWithPrimaryKey).QualifiedName;
end;

procedure TMapperTest.TheAnotherVariantValuesMustJustConvertToTValue;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);
  var Value: Variant := 123456;

  Table.FindField('Integer', Field);

  Assert.AreEqual(123456, Field.ConvertVariant(Value).AsInteger);

  Mapper.Free;
end;

procedure TMapperTest.TheClassWithTheSingleTableInheritanceAttributeCantBeMappedInTheTableList;
begin
  var Mapper := TMapper.Create;
  var Table: TTable;

  Mapper.LoadAll;

  Assert.IsFalse(Mapper.TryFindTable(TMyEntityWithSingleTableInheritanceAttribute.ClassInfo, Table));

  Mapper.Free;
end;

procedure TMapperTest.TheConversionOfTheTValueMustBeLikeExpected(TypeToConvert, ValueToCompare: String);
begin
  var FieldToCompare: TField := nil;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);
  var Value: TValue;

  for var Field in Table.Fields do
    if Field.PropertyInfo.Name = TypeToConvert then
      FieldToCompare := Field;

  if TypeToConvert = 'AnsiChar' then
    Value := TValue.From(AnsiChar('C'))
  else if TypeToConvert = 'AnsiString' then
    Value := TValue.From(AnsiString('AnsiString'))
  else if TypeToConvert = 'Char' then
    Value := TValue.From(Char('C'))
  else if TypeToConvert = 'Class' then
  begin
    var Obj := TMyEntityWithPrimaryKey.Create;
    Obj.Value := 1234;
    Value := Obj;
  end
  else if TypeToConvert = 'EmptyClass' then
    Value := TValue.From<TObject>(nil)
  else if TypeToConvert = 'Enumerator' then
    Value := TValue.From(Enum2)
  else if TypeToConvert = 'Float' then
    Value := 1234.456
  else if TypeToConvert = 'Date' then
    Value := TValue.From(EncodeDate(2020, 1, 31))
  else if TypeToConvert = 'DateTime' then
    Value := TValue.From(EncodeDateTime(2020, 1, 31, 12, 34, 56, 0))
  else if TypeToConvert = 'GUID' then
    Value := TValue.From(StringToGUID('{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}'))
  else if TypeToConvert = 'Integer' then
    Value := 1234
  else if TypeToConvert = 'Int64' then
    Value := Int64(1234)
  else if TypeToConvert = 'String' then
    Value := 'String'
  else if TypeToConvert = 'Time' then
    Value := TValue.From(TTime(EncodeTime(12, 34, 56, 0)))
  else
    raise Exception.Create('Test not mapped!');

  Assert.AreEqual(ValueToCompare, FieldToCompare.GetAsString(Value));

  if Value.IsObject then
    Value.AsObject.Free;

  Mapper.Free;
end;

procedure TMapperTest.TheDatabaseNameOfATableMustBeTheNameOfClassRemovingTheFirstCharOfTheClassName;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity);

  Assert.AreEqual('MyEntity', Table.DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.TheFieldInPrimaryKeyMustBeMarkedWithInPrimaryKey;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity);

  Assert.IsTrue(Table.PrimaryKey.InPrimaryKey);

  Mapper.Free;
end;

procedure TMapperTest.TheFieldLinkingTheParentAndChildOfManyValueAssociationMustBeLoaded;
begin
  var Mapper := TMapper.Create;

  var ChildTable := Mapper.LoadClass(TMyEntityWithManyValueAssociationChild);
  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(ChildTable.Fields[1], Table.ManyValueAssociations[0].ForeignKey.Field);

  Mapper.Free;
end;

procedure TMapperTest.TheFieldOfAForeignKeyMustBeFilledWithTheFieldOfTheClassThatIsAForeignKey;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual(Table.Fields[1], Table.ForeignKeys[0].Field);

  Mapper.Free;
end;

procedure TMapperTest.TheFieldsMustBeOrderedByPriorityFirstPrimaryKeyThenRegularFieldsThenForeignKeysThenManyValueAssociations;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TUnorderedClass);

  Assert.AreEqual('Id', Table.Fields[0].DatabaseName);
  Assert.AreEqual('AField', Table.Fields[1].DatabaseName);
  Assert.AreEqual('BField', Table.Fields[2].DatabaseName);
  Assert.AreEqual('LastField', Table.Fields[5].DatabaseName);
  Assert.AreEqual('IdALazy', Table.Fields[3].DatabaseName);
  Assert.AreEqual('IdBLazy', Table.Fields[4].DatabaseName);
  Assert.AreEqual('IdAForeignKey', Table.Fields[6].DatabaseName);
  Assert.AreEqual('IdBForeignKey', Table.Fields[7].DatabaseName);
  Assert.AreEqual('AManyValue', Table.Fields[8].DatabaseName);
  Assert.AreEqual('BManyValue', Table.Fields[9].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.TheFieldTablePropertyMustReturnTheFieldIfFoundIt;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyTestClass);

  Table.FindField('Field', Field);

  Assert.AreEqual(Field, Table.Field['Field']);

  Mapper.Free;
end;

procedure TMapperTest.TheFieldThatGenerateAForignKeyMustLoadThisInfoInTheField;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithForeignKey);

  Assert.IsNotNull(Table.Fields[1].ForeignKey);

  Mapper.Free;
end;

procedure TMapperTest.TheFindFieldFunctionMustReturnTheFieldDefinitionWhenFindTheField;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TUnorderedClass);

  Table.FindField('BForeignKey', Field);

  Assert.AreEqual(Table.Fields[7], Field);

  Mapper.Free;
end;

procedure TMapperTest.TheFindFieldFunctionMustReturnTrueIfTheFieldExistsInTheTable;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TUnorderedClass);

  Assert.IsTrue(Table.FindField('BForeignKey', Field));

  Mapper.Free;
end;

procedure TMapperTest.TheFindTableWithTypeInfoMustRaiseAnErrorIfNotFindTheTable;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.FindTable(TMyEntityWithoutEntityAttribute.ClassInfo);
    end, ETableNotFound);

  Mapper.Free;
end;

procedure TMapperTest.TheFindTableWithTypeInfoMustReturnTheTableHasExpected;
begin
  var Mapper := TMapper.Create;

  Mapper.LoadClass(TClassWithForeignKey);

  Assert.IsNotNull(Mapper.FindTable(TClassWithForeignKey.ClassInfo));

  Mapper.Free;
end;

procedure TMapperTest.TheForeignKeyCreatedForTheInheritanceMustBeMarkedHasInheritanceLink;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  Assert.IsTrue(Table.ForeignKeys[0].IsInheritedLink);

  Mapper.Free;
end;

procedure TMapperTest.TheForeignKeyDatabaseNameMustBeTheConcatenationOfTheTablesAndFieldInfo;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityForeignKeyAlias);

  Assert.AreEqual('FK_MyEntityForeignKeyAlias_MyEntityInheritedFromSimpleClass_IdForeignKey', Table.ForeignKeys[0].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.TheForeignKeyInTheInheritedClassMustBeAReferenceToThePrimaryKeyInfo;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  var ForeignKey := Table.ForeignKeys[0];

  Assert.AreEqual(TFieldPrimaryKeyReference, ForeignKey.Field.ClassType);

  Mapper.Free;
end;

procedure TMapperTest.TheFunctionGetValueFromFieldMustReturnTheValueOfThePropertyOfTheField;
begin
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  MyClass.&String := 'My Field';

  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);
  var Field := Table.Fields[10];

  Assert.AreEqual('My Field', Field.GetValue(MyClass).AsString);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.TheGetCacheFunctionWithAnInstanceMustBuildTheKeyWithTheClassOfTheInstanceNotFromTable;
begin
  var Mapper := TMapper.Create;
  var MyClass := TClassForeignKey.Create;
  MyClass.Id := 123456;
  var Table := Mapper.LoadClass(TClassWithPrimaryKey);

  Assert.AreEqual('Delphi.ORM.Test.Entity.TClassForeignKey.123456', Table.GetCacheKey(MyClass));

  MyClass.Free;

  Mapper.Free;
end;

procedure TMapperTest.TheLoadingOfForeingKeyMustBeAfterAllTablesAreLoadedToTheFindTableWorksPropertily;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TZZZZ);

  Assert.IsNotNull(Table.ForeignKeys[0].ParentTable);

  Mapper.Free;
end;

procedure TMapperTest.TheManyValueAssociationMustLoadTheFieldThatGeneratedTheValue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(Table.Fields[1], Table.ManyValueAssociations[0].Field);

  Mapper.Free;
end;

procedure TMapperTest.TheNameOfManyValueAssociationLinkCanBeDefinedByTheAttributeToTheLinkHappen;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  Assert.AreEqual('ManyValueAssociation', Table.ManyValueAssociations[0].ForeignKey.Field.PropertyInfo.Name);

  Mapper.Free;
end;

procedure TMapperTest.ThenMakeAForeignKeyToASingleTableInheritanceMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TMyEntityForeignKeyToAnotherSingle);
    end, EForeignKeyToSingleTableInheritanceTable);

  Mapper.Free;
end;

procedure TMapperTest.TheParentTableMustBeTheTableLinkedToTheField;
begin
  var Mapper := TMapper.Create;

  var ParentTable := Mapper.LoadClass(TMyEntityWithPrimaryKey);
  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual(ParentTable, Table.ForeignKeys[0].ParentTable);

  Mapper.Free;
end;

procedure TMapperTest.ThePrimaryKeyCantBeNullable;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TClassWithPrimaryKeyNullableProperty);
    end, EClassWithPrimaryKeyNullable);

  Mapper.Free;
end;

procedure TMapperTest.ThePrimaryKeyFieldReferenceMustHaveTheFieldTypeWithTheBaseClassType;
begin
  var Mapper := TMapper.Create;
  var TableChild := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);
  var TableParent := Mapper.LoadClass(TMyEntityInheritedFromSingle);

  Assert.AreEqual<TRttiType>(TableParent.ClassTypeInfo, TableChild.Fields[0].FieldType);

  Mapper.Free;
end;

procedure TMapperTest.ThePrimaryKeyReferenceFieldCantBeMarkedHasAutoGenerated;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  Assert.IsFalse(Table.Fields[0].AutoGenerated);

  Mapper.Free;
end;

procedure TMapperTest.TheTableOfManyValueAssociationMustBeTheChildTableOfThisLink;
begin
  var Mapper := TMapper.Create;

  var ChildTable := Mapper.LoadClass(TMyEntityWithManyValueAssociationChild);
  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  Assert.AreEqual(ChildTable, Table.ManyValueAssociations[0].ChildTable);

  Mapper.Free;
end;

procedure TMapperTest.WhenAClassDoesNotHaveThePrimaryKeyAttributeAndHasAnIdFieldThisWillBeThePrimaryKey;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity2);

  Assert.AreEqual('Id', Table.PrimaryKey.DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeCantGenerateAnyForeignKey;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<Integer>(0, Length(Mapper.LoadClass(TMyEntityInheritedFromSingle).ForeignKeys));

  Mapper.Free;
end;

procedure TMapperTest.WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeMustLoadAllFieldsInTheTable;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<Integer>(3, Length(Mapper.LoadClass(TMyEntityInheritedFromSingle).Fields));

  Mapper.Free;
end;

procedure TMapperTest.WhenAClassIsInheritedFromAClassWithTheSingleTableInheritanceAttributeThePrimaryKeyMustBeLoadedFromTheTopClass;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityInheritedFromSingle);

  Assert.IsTrue(Assigned(Table.PrimaryKey));

  Mapper.Free;
end;

procedure TMapperTest.WhenAClassWithManyValueAssociationHasAChildClassWithMoreThenOneForeignKeyToParentClassMustLoadTheForeignKeyWithTheSameNameOfTheParentTable;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TManyValueAssociationParent);

  Assert.AreEqual('IdManyValueAssociationParent', Table.ManyValueAssociations[0].ForeignKey.Field.DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenAFieldIsAForeignKeyThePropertyIsForeignKeyMustReturnTrue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociationChild);

  var Field := Table.Fields[1];

  Assert.IsTrue(Field.IsForeignKey);

  Mapper.Free;
end;

procedure TMapperTest.WhenAFieldIsAForeignKeyThePropertyIsJoinLinkMustReturnTrue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociationChild);

  var Field := Table.Fields[1];

  Assert.IsTrue(Field.IsJoinLink);

  Mapper.Free;
end;

procedure TMapperTest.WhenAFieldIsAManyValueAssociationThePropertyIsJoinLinkReturnTrue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  var Field := Table.Fields[1];

  Assert.IsTrue(Field.IsJoinLink);

  Mapper.Free;
end;

procedure TMapperTest.WhenAFieldIsAManyValueAssociationThePropertyIsManyValueAssociationReturnTrue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  var Field := Table.Fields[1];

  Assert.IsTrue(Field.IsManyValueAssociation);

  Mapper.Free;
end;

procedure TMapperTest.WhenAFieldIsWithTheAutoGeneratedAttributeMustLoadAsTrueThePropertyInField;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity);

  Assert.IsTrue(Table.Fields[0].AutoGenerated);

  Mapper.Free;
end;

procedure TMapperTest.WhenAForeignKeyFieldHasTheFieldNameAttributeThisMustBeTheDatabaseNameField;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TClassWithNamedForeignKey);

  Assert.AreEqual('MyFk', Table.Fields[1].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenAPropertyIsAnArrayMustLoadAManyValueLink;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  Assert.AreEqual<Integer>(1, Length(Table.ManyValueAssociations));

  Mapper.Free;
end;

procedure TMapperTest.WhenATableIsLoadedMustFillTheMapperPropertyOfTheTable;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(Mapper, Table.Mapper);

  Mapper.Free;
end;

procedure TMapperTest.WhenCallGetCacheKeyMustBuildTheValueOfTheCacheKeyWithThePrimaryKeyValueFromTheClass;
begin
  var Mapper := TMapper.Create;
  var MyClass := TClassWithPrimaryKey.Create;
  MyClass.Id := 123456;
  var Table := Mapper.LoadClass(TClassWithPrimaryKey);

  Assert.AreEqual('Delphi.ORM.Test.Entity.TClassWithPrimaryKey.123456', Table.GetCacheKey(MyClass));

  MyClass.Free;

  Mapper.Free;
end;

procedure TMapperTest.WhenCallGetCacheValueWithVariantAndTheTableDontHavePrimaryKeyMustLoadTheKeyAsExpected;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithoutPrimaryKey);

  Assert.AreEqual('Delphi.ORM.Test.Entity.TMyEntityWithoutPrimaryKey.', Table.GetCacheKey(1234));

  Mapper.Free;
end;

procedure TMapperTest.WhenCallGetCacheValueWithVariantMustBuildTheKeyAsExpected;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithPrimaryKey);

  Assert.AreEqual('Delphi.ORM.Test.Entity.TClassWithPrimaryKey.123456', Table.GetCacheKey(123456));

  Mapper.Free;
end;

procedure TMapperTest.WhenCallLoadAllMoreThemOneTimeCantRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Mapper.LoadAll;

  Assert.WillNotRaise(Mapper.LoadAll);

  Mapper.Free;
end;

procedure TMapperTest.WhenCallLoadAllMustLoadAllClassesWithTheEntityAttribute;
begin
  var Mapper := TMapper.Create;

  Mapper.LoadAll;

  Assert.IsTrue(Length(Mapper.Tables) > 0, 'No entities loaded!');

  Mapper.Free;
end;

procedure TMapperTest.WhenFillAnEmptyValueToALazyFieldTheLazyValueCantBeMarkedAsLoaded;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  var Field := Table.Fields[1];

  Field.SetValue(MyClass, 1234);

  Field.SetValue(MyClass, TValue.Empty);

  Assert.IsFalse(MyClass.Lazy.Access.HasValue);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenFillTheFieldValueOfALazyFieldAndTheValueIsNotAnInstanceOfAnObjectMustLoadTheKeyValueFromLazy;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  var Field := Table.Fields[1];

  Field.SetValue(MyClass, 1234);

  Assert.AreEqual(1234, MyClass.Lazy.Access.Key.AsInteger);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenFillTheFieldValueOfALazyPropertyMustLoadPrimaryKeyFieldName;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  var Field := Table.Fields[1];

  Field.SetValue(MyClass, 1234);

  Assert.AreEqual('Id', MyClass.Lazy.Access.FieldName);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenGetPropertyValueMustReturnTheValueOfTheProperty;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  MyClass.Id := 123;
  var Table := Mapper.LoadClass(TLazyClass);

  Assert.AreEqual(123, Table.Fields[0].GetPropertyValue(MyClass).AsInteger);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenGetTheLazyAccessValueMustReturnTheLazyAccess;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  var LazyAccess := Table.Fields[1].GetLazyAccess(MyClass);

  Assert.IsNotNull(LazyAccess);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenGetTheStringValueOfANullableTypeAndTheValueIsFilledMustReturnTheValue;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithNullableProperty);
  var TheValue := TClassWithNullableProperty.Create;
  TheValue.Nullable := 123456;

  Assert.AreEqual('123456', Table.Fields[1].GetAsString(TheValue));

  Mapper.Free;

  TheValue.Free;
end;

procedure TMapperTest.WhenGetTheStringValueOfANullableTypeAndTheValueIsNullMustReturnTheNullStringValue;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithNullableProperty);
  var TheValue := TClassWithNullableProperty.Create;

  Assert.AreEqual('null', Table.Fields[1].GetAsString(TheValue));

  Mapper.Free;

  TheValue.Free;
end;

procedure TMapperTest.WhenGetTheStringValueOfLazyPropertyMustReturnTheKeyValueIfIsNotLoaded;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TLazyClass);
  var TheValue := TLazyClass.Create;

  TheValue.Lazy.Access.Key := 123456;

  Assert.AreEqual('123456', Table.Fields[1].GetAsString(TheValue));

  Mapper.Free;

  TheValue.Free;
end;

procedure TMapperTest.WhenGetTheStringValueOfLazyPropertyMustReturnThePrimaryKeyValueOfLoadedValue;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TLazyClass);
  var TheEntity := TMyEntity.Create;
  var TheValue := TLazyClass.Create;
  TheValue.Lazy := TheEntity;
  TheValue.Lazy.Value.Id := 123456;

  Assert.AreEqual('123456', Table.Fields[1].GetAsString(TheValue));

  Mapper.Free;

  TheEntity.Free;

  TheValue.Free;
end;

procedure TMapperTest.WhenGetTheValueOfTheFieldAsStringMustBuildTheStringAsExpected(FieldName: String);
begin
  var FieldToCompare: TField := nil;
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  var ValueToCompare := EmptyStr;

  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  MyClass.AnsiChar := 'C';
  MyClass.AnsiString := 'AnsiString';
  MyClass.Char := 'C';
  MyClass.&Class := TMyEntityWithPrimaryKey.Create;
  MyClass.&Class.Value := 222.333;
  MyClass.Date := EncodeDate(2020, 1, 31);
  MyClass.DateTime := EncodeDate(2020, 1, 31) + EncodeTime(12, 34, 56, 0);
  MyClass.Enumerator := Enum2;
  MyClass.Float := 1234.456;
  MyClass.GUID := StringToGUID('{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}');
  MyClass.Integer := 1234;
  MyClass.Int64 := 1234;
  MyClass.&String := 'String';
  MyClass.Time := EncodeTime(12, 34, 56, 0);

  for var Field in Table.Fields do
    if Field.PropertyInfo.Name = FieldName then
      FieldToCompare := Field;

  case FieldToCompare.PropertyInfo.PropertyType.TypeKind of
    tkChar, tkWChar: ValueToCompare := '''C''';
    tkEnumeration: ValueToCompare := '1';
    tkFloat:
    begin
      if FieldToCompare.PropertyInfo.PropertyType.Handle = TypeInfo(TDate) then
        ValueToCompare := '''2020-01-31'''
      else if FieldToCompare.PropertyInfo.PropertyType.Handle = TypeInfo(TTime) then
        ValueToCompare := '''12:34:56'''
      else if FieldToCompare.PropertyInfo.PropertyType.Handle = TypeInfo(TDateTime) then
        ValueToCompare := '''2020-01-31T12:34:56.000'''
      else
        ValueToCompare := '1234.456';
    end;
    tkInteger, tkInt64: ValueToCompare := '1234';
    tkRecord: ValueToCompare := '''{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}''';
    tkLString: ValueToCompare := '''AnsiString''';
    tkUString: ValueToCompare := '''String''';
    tkClass:
      if FieldName = 'Class' then
        ValueToCompare := '222.333'
      else
        ValueToCompare := 'null';
  end;

  Assert.AreEqual(ValueToCompare, FieldToCompare.GetAsString(MyClass));

  MyClass.&Class.Free;

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenGetValueOfAndFieldNullableMustReturnEmptyIfHasNoValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TClassWithNullableProperty.Create;
  var Table := Mapper.LoadClass(MyClass.ClassType);

  var Field := Table.Fields[1];

  Assert.IsTrue(Field.GetValue(MyClass).IsEmpty);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenLoadAClassMustKeepTheOrderingOfTablesToTheFindTableContinueToWorking;
begin
  var Mapper := TMapper.Create;

  Mapper.LoadClass(TMyEntity2);

  Mapper.LoadClass(TMyEntity);

  Mapper.LoadClass(TMyEntity3);

  var Table := Mapper.FindTable(TMyEntity);

  Assert.AreEqual<TRttiType>(FContext.GetType(TMyEntity), Table.ClassTypeInfo);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadAFieldMustFillThePropertyWithThePropertyInfo;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity3);
  var TypeInfo := FContext.GetType(TMyEntity3).GetProperties[0];

  Assert.AreEqual<TObject>(TypeInfo, Table.Fields[0].PropertyInfo);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadAFieldMustLoadTheFieldTypeWithTheTypeOfTheProperty;
begin
  var IntegerType := FContext.GetType(TypeInfo(Integer));
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithNullableProperty);

  Assert.AreEqual(IntegerType, Table.Fields[0].FieldType);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadALazyFieldMustLoadTheFieldTypeWithTheInternalLazyType;
begin
  var ClassType := FContext.GetType(TypeInfo(TMyEntity));
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  Assert.AreEqual(ClassType, Table.Fields[1].FieldType);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadANullableFieldMustLoadTheFieldTypeWithTheInternalNullableType;
begin
  var IntegerType := FContext.GetType(TypeInfo(Integer));
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithNullableProperty);

  Assert.AreEqual(IntegerType, Table.Fields[1].FieldType);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadATableMustLoadAllFieldsToo;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntity);

  Assert.AreEqual<Integer>(3, Length(Table.Fields));

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadATableWithSingleInheritenceMustLoadTheFieldsOfAllLevels;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<NativeInt>(4, Length(Mapper.LoadClass(TAnotherSingleInheritedConcrete).Fields));

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadMoreThenOneTimeTheSameClassCantRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Mapper.LoadClass(TMyEntity);

      Mapper.LoadClass(TMyEntity);
    end);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadTheFieldOfATableMustLoadTheNameOfTheFieldWithThePropertyName;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual('Name', Table.Fields[0].Name);

  Mapper.Free;
end;

procedure TMapperTest.WhenLoadTheIndexMustLoadTheNameOfTheIndexHasExpected;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyClassWithIndex);

  Assert.AreEqual('MyIndex', Table.Indexes[0].DatabaseName);
  Assert.AreEqual('MyIndex2', Table.Indexes[1].DatabaseName);
  Assert.AreEqual('MyUnique', Table.Indexes[2].DatabaseName);
end;

procedure TMapperTest.WhenLoadTheTableMustLoadTheNameOfTheTableWithTheNameOfTheClassWithoutTheTChar;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity2);

  Assert.AreEqual('MyEntity2', Table.Name);

  Mapper.Free;
end;

procedure TMapperTest.WhenMapAForeignKeyIsToAClassWithoutAPrimaryKeyMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TMyEntityForeignKeyToClassWithoutPrimaryKey);
    end, EClassWithoutPrimaryKeyDefined);

  Mapper.Free;
end;

procedure TMapperTest.WhenMappingALazyArrayClassCantRaiseAnyError;
begin
  var Mapper := TMapper.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Mapper.LoadClass(TLazyArrayClass);
    end);

  Mapper.Free;
end;

procedure TMapperTest.WhenMappingALazyArrayClassMustLoadTheFieldWithTheExpectedPropertyValueFilled;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TLazyArrayClass);

  Assert.IsTrue(Table.Fields[1].IsForeignKey);
  Assert.IsTrue(Table.Fields[1].IsJoinLink);
  Assert.IsTrue(Table.Fields[2].IsManyValueAssociation);

  Mapper.Free;
end;

procedure TMapperTest.WhenSetValueFieldMustLoadThePropertyOfTheClassAsWithTheValueExpected(FieldName: String);
begin
  var FieldToCompare: TField := nil;
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  var ValueToCompare := NULL;

  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  for var Field in Table.Fields do
    if Field.DatabaseName = FieldName then
      FieldToCompare := Field;

  case FieldToCompare.PropertyInfo.PropertyType.TypeKind of
    tkChar: ValueToCompare := AnsiChar('C');
    tkEnumeration: ValueToCompare := Enum2;
    tkFloat: ValueToCompare := Double(1234.456);
    tkInt64: ValueToCompare := Int64(1234);
    tkInteger: ValueToCompare := 1234;
    tkRecord: ValueToCompare := '{BD2BBA84-C691-4C5E-ABD3-4F32937C53F8}';
    tkLString: ValueToCompare := AnsiString('AnsiString');
    tkUString: ValueToCompare := 'String';
    tkWChar: ValueToCompare := Char('C');
  end;

  FieldToCompare.SetValue(MyClass, ValueToCompare);

  if FieldToCompare.PropertyInfo.PropertyType.TypeKind = tkRecord then
    Assert.AreEqual<String>(ValueToCompare, FieldToCompare.GetValue(MyClass).AsType<TGUID>.ToString)
  else
    Assert.AreEqual(ValueToCompare, FieldToCompare.GetValue(MyClass).AsVariant);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenSetValueToAFieldWithASharedObjectMustUpdateThePropertyHasExpected;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  var MyObject := TSharedObject.Create(MyClass) as ISharedObject;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Table.FindField('Integer', Field);

  Field.SetValue(MyObject, 20);

  Assert.AreEqual(20, MyClass.Integer);

  Mapper.Free;

  MyObject := nil;
end;

procedure TMapperTest.WhenSetValueToAFieldWithAStateObjectMustUpdateBothObjectsHasExpected;
begin
  var Field: TField;
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  var MyObject := TStateObject.Create(MyClass, False) as IStateObject;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Table.FindField('Integer', Field);

  Field.SetValue(MyObject, 20);

  Assert.AreEqual(20, MyClass.Integer, 'The object');

  Assert.AreEqual(20, TMyEntityWithAllTypeOfFields(MyObject.OldObject).Integer, 'The old object');

  Mapper.Free;

  MyObject := nil;
end;

procedure TMapperTest.WhenSetValueToALazyPropertyCantRaiseAnyError;
begin
  var LazyValue := TMyEntity.Create;
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  var Field := Table.Fields[1];

  Assert.WillNotRaise(
    procedure
    begin
      Field.SetValue(MyClass, LazyValue);
    end);

  Mapper.Free;

  MyClass.Free;

  LazyValue.Free;
end;

procedure TMapperTest.WhenSetValueToALazyPropertyMustLoadTheValueInTheProperty;
begin
  var LazyValue := TMyEntity.Create;
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  var Field := Table.Fields[1];

  Field.SetValue(MyClass, LazyValue);

  Assert.AreEqual<TObject>(LazyValue, Field.GetValue(MyClass).AsObject);

  Mapper.Free;

  MyClass.Free;

  LazyValue.Free;
end;

procedure TMapperTest.WhenTheChildClassIsDeclaredBeforeTheParentClassTheLinkBetweenOfTablesMustBeCreated;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithManyValueAssociation);

  Assert.AreEqual<Integer>(1, Length(Table.ManyValueAssociations));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassDontHaveAPrimaryKeyMustLoadTheCacheKeyWithoutThePrimaryKeyValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithoutPrimaryKey.Create;
  var Table := Mapper.LoadClass(TMyEntityWithoutPrimaryKey);

  Assert.AreEqual('Delphi.ORM.Test.Entity.TMyEntityWithoutPrimaryKey.', Table.GetCacheKey(MyClass));

  MyClass.Free;

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassHasAForeignKeyAndTheKeyTableIsntLoadedMustLoadTheTableFirstAndNotRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Mapper.LoadClass(TMyEntityForeignKeyAlias);
    end);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassHasASimpleInheritenceMustLoadTheBaseTableProperty;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  Assert.AreEqual(Mapper.FindTable(TMyEntityInheritedFromSingle), Table.BaseTable);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassHasTheIndexAnnotationMustLoadTheIndexInfoOfTheTable;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyClassWithIndex);

  Assert.AreEqual<NativeInt>(3, Length(Table.Indexes));
end;

procedure TMapperTest.WhenTheClassHaveThePrimaryKeyAttributeThePrimaryKeyWillBeTheFieldFilled;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithPrimaryKey);

  Assert.AreEqual('Value', Table.PrimaryKey.DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassHaveTheTableNameAttributeTheDatabaseNameMustBeLikeTheNameInAttribute;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity2);

  Assert.AreEqual('AnotherTableName', Table.DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassInheritsFromObjectCantRaiseAnyError;
begin
  var Mapper := TMapper.Create;

  Assert.WillNotRaise(
    procedure
    begin
      Mapper.LoadClass(TZZZZ);
    end);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassIsInheritedFromANormalClassCantLoadFieldsFormTheBaseClass;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<Integer>(2, Length(Mapper.LoadClass(TMyEntityInheritedFromSimpleClass).Fields));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassIsInheritedFromANormalClassMustCreateAForeignKeyForTheBaseClass;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<Integer>(1, Length(Mapper.LoadClass(TMyEntityInheritedFromSimpleClass).ForeignKeys));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassIsInheritedFromTObjectCantCreateAForeignKeyForThatClass;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<Integer>(0, Length(Mapper.LoadClass(TMyEntity).ForeignKeys));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassIsInheritedMustLoadTheCascadeInfoWithUpdateAndInsertCascade;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  Assert.AreEqual<TCascadeTypes>([ctInsert, ctUpdate], Table.ForeignKeys[0].Cascade);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassIsInheritedMustLoadThePrimaryKeyFromBaseClass;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  Assert.IsTrue(Assigned(Table.PrimaryKey));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheClassIsInheritedMustShareTheSamePrimaryKeyFromTheBaseClass;
begin
  var Mapper := TMapper.Create;

  var BaseTable := Mapper.LoadClass(TMyEntityInheritedFromSingle);
  var Table := Mapper.LoadClass(TMyEntityInheritedFromSimpleClass);

  Assert.AreSame(BaseTable.PrimaryKey, Table.PrimaryKey);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsADateMustConvertTheValueAsExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual(EncodeDate(2021, 08, 02), FindField(Table, 'Date').DefaultValue.AsType<TDate>);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsADateTimeMustConvertTheValueAsExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual(EncodeDateTime(2021, 08, 02, 11, 0, 30, 0), FindField(Table, 'DateTime').DefaultValue.AsType<TDateTime>);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsAFloatNumberMustConvertTheValueAsExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual<Double>(123.456, FindField(Table, 'Float').DefaultValue.AsType<Double>);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsAnEnumeratorMustConvertTheValueAsExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual(Enum3, FindField(Table, 'AEnum').DefaultValue.AsType<TMyEnumerator>);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsAnEnumeratorWithAnInvalidNameMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TMyEntityWithInvalidDefaultValue);
    end, EInvalidEnumeratorName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsAnIntegerMustConvertTheValueAsExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual(123456, FindField(Table, 'Int').DefaultValue.AsType<Integer>);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheDefaultValueIsATimeMustConvertTheValueAsExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual(EncodeTime(11, 0, 30, 0), FindField(Table, 'Time').DefaultValue.AsType<TTime>);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasFieldInfoAttributeWithSpecialTypeFilledMustLoadThisInfoInTheField;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyTestClass);

  Assert.AreEqual(stUniqueIdentifier, Table.Fields[0].SpecialType);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasDefaultValueWithAnInternalFunctionMustLoadTheInfoHasExpected;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual(difNow, Table['DefaultInternalFunction'].DefaultInternalFunction);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasFieldInfoAttributeWithPrecisionAndScaleFilledMustLoadThisInfoInTheField;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyTestClass);

  Assert.AreEqual(15, Table.Fields[2].Size);
  Assert.AreEqual(7, Table.Fields[2].Scale);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasFieldInfoAttributeWithSizeFilledMustLoadThisInfoInTheField;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyTestClass);

  Assert.AreEqual(150, Table.Fields[1].Size);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasntADefaultValueTheValueMustBeEmpty;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyTestClass);

  Assert.AreEqual(TValue.Empty, Table.Fields[0].DefaultValue);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasTheDefaultAttributeMustLoadTheDefaultProperyWithTheValue;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithDefaultValue);

  Assert.AreEqual('abcde', FindField(Table, 'AField').DefaultValue.AsString);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasTheInsertCascadeAndUpdateCascadeAnotationMustLoadTheInfoInTheForeignKey;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TManyValueAssociationWithThreeForeignKey);

  Assert.AreEqual<TCascadeTypes>([ctInsert, ctUpdate], Table.ForeignKeys[2].Cascade);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasTheInsertCascadeAnotationMustLoadTheInfoInTheForeignKey;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TManyValueAssociationWithThreeForeignKey);

  Assert.AreEqual<TCascadeTypes>([ctInsert], Table.ForeignKeys[1].Cascade);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasTheNoUpdateAttributeTheFieldMustBeMarkedAsReadOnly;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithNoUpdateAttribute);

  Assert.IsTrue(Table.Fields[1].IsReadOnly);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHasTheUpdateCascadeAnotationMustLoadTheInfoInTheForeignKey;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TManyValueAssociationWithThreeForeignKey);

  Assert.AreEqual<TCascadeTypes>([ctUpdate], Table.ForeignKeys[0].Cascade);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldHaveTheFieldNameAttributeMustLoadThisNameInTheDatabaseName;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual('AnotherFieldName', Table.Fields[0].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsAClassMustFillTheDatabaseNameWithIdPlusPropertyName;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.AreEqual('IdMyForeignKey', Table.Fields[1].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsAForeignKeyMustAppendTheIdInTheDatabaseNameOfTheField;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TLazyClass);

  Assert.AreEqual('IdLazy', Table.Fields[1].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsMappedMustLoadTheReferenceToTheTableOfTheField;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity);

  Assert.AreEqual(Table, Table.Fields[0].Table);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsOfDateTimeTypeMustLoadTheSpecialTypeWithDateTime;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stDateTime, Table.Field['DateTime'].SpecialType);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsOfDateTypeMustLoadTheSpecialTypeWithDate;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stDate, Table.Field['Date'].SpecialType);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldIsOfTimeTypeMustLoadTheSpecialTypeWithTime;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  Assert.AreEqual(stTime, Table.Field['Time'].SpecialType);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldsAreLoadedMustFillTheNameWithTheNameOfPropertyOfTheClass;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity3);

  Assert.AreEqual('Id', Table.Fields[0].DatabaseName);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheFieldValueIsNullMustLoadTheFieldWithTheEmptyValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TMyEntityWithAllTypeOfFields.Create;
  MyClass.Enumerator := Enum3;

  var Table := Mapper.LoadClass(TMyEntityWithAllTypeOfFields);

  var Field := Table.Fields[6];

  Field.SetValue(MyClass, NULL);

  Assert.AreEqual(Enum1, Field.GetValue(MyClass).AsType<TMyEnumerator>);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenTheForeignKeyIsAClassAliasMustLoadTheForeignClassAndLinkToForeignKey;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithForeignKeyAlias);

  Assert.AreEqual<Integer>(1, Length(Table.ForeignKeys));

  Mapper.Free;
end;

procedure TMapperTest.WhenTheForeignKeyIsCreatesMustLoadTheParentTable;
begin
  var Mapper := TMapper.Create;

  var Table := Mapper.LoadClass(TMyEntityWithFieldNameAttribute);

  Assert.IsNotNull(Table.ForeignKeys[0].ParentTable);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheLazyPropertyIsLoadedMustReturnTheInternalValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;
  var TheClass := TMyEntity.Create;

  MyClass.Lazy := TheClass;

  var Table := Mapper.LoadClass(TLazyClass);
  var Field := Table.Fields[1];

  Assert.AreEqual<TObject>(TheClass, Field.GetValue(MyClass).AsObject);

  Mapper.Free;

  MyClass.Free;

  TheClass.Free;
end;

procedure TMapperTest.WhenTheLinkBetweenTheManyValueAssociationAndTheChildTableForeignKeyDontExistsMustRaiseAnError;
begin
  var Mapper := TMapper.Create;

  Assert.WillRaise(
    procedure
    begin
      Mapper.LoadClass(TManyValueAssociationParentNoLink);
    end, EManyValueAssociationLinkError);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheNullablePropertyIsFilledWithAValueMustLoadTheValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TClassWithNullableProperty.Create;
  var Table := Mapper.LoadClass(MyClass.ClassType);

  var Field := Table.Fields[1];

  Field.SetValue(MyClass, 123456);

  Assert.AreEqual<Integer>(123456, MyClass.Nullable.Value);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenTheNullablePropertyIsFilledWithTheNullValueMustMarkAsNullTheValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TClassWithNullableProperty.Create;
  var Table := Mapper.LoadClass(MyClass.ClassType);

  var Field := Table.Fields[1];

  Field.SetValue(MyClass, Null);

  Assert.IsTrue(MyClass.Nullable.IsNull);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenTheNullablePropertyIsLoadedMustReturnTheFilled;
begin
  var Mapper := TMapper.Create;
  var MyClass := TClassWithNullableProperty.Create;
  MyClass.Nullable := 123456;
  var Table := Mapper.LoadClass(MyClass.ClassType);

  var Field := Table.Fields[1];

  Assert.AreEqual(123456, Field.GetValue(MyClass).AsInteger);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenThePropertyIsLazyLoadingAndIsntLoadedMustReturnTheKeyValueInTheGetValue;
begin
  var Mapper := TMapper.Create;
  var MyClass := TLazyClass.Create;

  MyClass.Lazy.Access.Key := 12345;

  var Table := Mapper.LoadClass(TLazyClass);
  var Field := Table.Fields[1];

  Assert.AreEqual(12345, Field.GetValue(MyClass).AsInteger);

  Mapper.Free;

  MyClass.Free;
end;

procedure TMapperTest.WhenThePropertyIsLazyMustCreateTheForeignKeyToThisProperty;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  Assert.AreEqual<Integer>(1, Length(Table.ForeignKeys));

  Mapper.Free;
end;

procedure TMapperTest.WhenThePropertyIsLazyMustFillWithTrueTheIsLazyPropertyInTheField;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TLazyClass);

  Assert.IsTrue(Table.Fields[1].IsLazy);

  Mapper.Free;
end;

procedure TMapperTest.WhenThePropertyIsNullableMustMarkTheFieldAsNullable;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TClassWithNullableProperty);

  Assert.IsTrue(Table.Fields[1].IsNullable);

  Mapper.Free;
end;

procedure TMapperTest.WhenTheTableIsInheritedMustLoadAllManyValueAssociationOfTheClass;
begin
  var Mapper := TMapper.Create;

  Assert.AreEqual<NativeInt>(1, Length(Mapper.LoadClass(TManyValueClassInherited).ManyValueAssociations));

  Mapper.Free;
end;

procedure TMapperTest.WhenTryToFindATableMustReturnTheTableOfTheClass;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyEntity3);

  Assert.AreEqual(TMyEntity3, Table.ClassTypeInfo.MetaclassType);

  Mapper.Free;
end;

procedure TMapperTest.WhenUseTheUniqueIndexAttributeMustMarkTheIndexAsUnique;
begin
  var Mapper := TMapper.Create;
  var Table := Mapper.LoadClass(TMyClassWithIndex);

  Assert.IsTrue(Table.Indexes[2].Unique);
end;

{ TFieldPrimaryKeyReferenceTest }

procedure TFieldPrimaryKeyReferenceTest.IfTryToFillAValueMustRaiseAnError;
begin
  var Field := TFieldPrimaryKeyReference.Create;

  Assert.WillRaise(
    procedure
    begin
      Field.SetValue(nil, TValue.Empty)
    end, ECanSetValueForFieldPrimaryKeyReference);

  Field.Free;
end;

procedure TFieldPrimaryKeyReferenceTest.TheReferenceFieldMustBeMarkedHasPrimaryKey;
begin
  var Field := TFieldPrimaryKeyReference.Create;

  Assert.IsTrue(Field.InPrimaryKey);

  Field.Free;
end;

procedure TFieldPrimaryKeyReferenceTest.WhenGetTheValueMustReturnTheInstanceFromTheParam;
begin
  var AClass := TMyEntityInheritedFromSimpleClass.Create;
  var Field := TFieldPrimaryKeyReference.Create;

  Assert.AreEqual<TObject>(AClass, Field.GetValue(AClass).AsObject);

  Field.Free;

  AClass.Free;
end;

procedure TFieldPrimaryKeyReferenceTest.WhenGetTheValueMustReturnTheInstanceOfTheBaseClassOfTheInstanceParam;
begin
  var AClass := TMyEntityInheritedFromSimpleClass.Create;
  var Field := TFieldPrimaryKeyReference.Create;

  Assert.AreEqual<Pointer>(TMyEntityInheritedFromSingle.ClassInfo, Field.GetValue(AClass).TypeInfo);

  Field.Free;

  AClass.Free;
end;

procedure TFieldPrimaryKeyReferenceTest.WhenTheFieldIsCreatedMustBeMarkedIsReference;
begin
  var Field := TFieldPrimaryKeyReference.Create;

  Assert.IsTrue(Field.IsReference);

  Field.Free;
end;

end.

